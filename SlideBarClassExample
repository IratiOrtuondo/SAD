import java.util.Observable;

class Value extends Observable {
	private int value; // Almacena el valor actual
	public int max;   // Almacena el valor máximo permitido

	// Constructor
	Value() {
    	value = 0; // Inicializa el valor en 0
	}

	// Método para incrementar el valor
	void inc() {
    	setChanged(); // Marca el estado como cambiado
    	if (value < max) { // Verifica si el valor actual es menor que el máximo
        	value++;
        	notifyObservers(new ConsoleBar.Command(ConsoleBar.Opcode.INC)); // Notifica a los observadores que se ha incrementado el valor
    	} else {
        	notifyObservers(new ConsoleBar.Command(ConsoleBar.Opcode.BELL)); // Notifica si se intenta exceder el valor máximo
    	}
	}

	// Método para decrementar el valor
	void dec() {
    	setChanged(); // Marca el estado como cambiado
    	if (value > 0) { // Verifica si el valor actual es mayor que 0
        	value--;
        	notifyObservers(new ConsoleBar.Command(ConsoleBar.Opcode.DEC)); // Notifica a los observadores que se ha decrementado el valor
    	} else {
        	notifyObservers(new ConsoleBar.Command(ConsoleBar.Opcode.BELL)); // Notifica si se intenta ir por debajo de 0
    	}
	}

	// Método para obtener el valor actual
	int get() {
    	return value; // Retorna el valor actual
	}

	// Método para establecer el valor máximo
	void setMax(int max) {
    	this.max = max; // Establece el valor máximo
	}
}



import java.io.*;
import static java.lang.System.in;

public class SlideBar {

	private static void setRaw() {
    	// Configura el terminal en modo "raw"
  	try {
        	Runtime.getRuntime().exec(new String[] { "/bin/sh", "-c", "stty -echo raw </dev/tty" }).waitFor();
    	} catch (IOException | InterruptedException e) {
        	System.err.println("Error al establecer modo raw: " + e.getMessage());
        	e.printStackTrace(); // Opción para depuración
    	}
	}
 
	private static void unsetRaw() {
    	// Restaura el terminal a modo "cooked"
    	try {
        	Runtime.getRuntime().exec(new String[] { "/bin/sh", "-c", "stty echo cooked </dev/tty" }).waitFor();
    	} catch (IOException | InterruptedException e) {
        	System.err.println("Error al regresar al modo normal: " + e.getMessage());
        	e.printStackTrace(); // Opción para depuración
    	}
	}
 
	static final int RIGHT = 0, LEFT = 1;
 
	public static int readArrow() throws IOException {
    	int ch;
    	// Leer el carácter hasta que se presiona Enter
        	ch = in.read();
        	if (ch == 27) { // Si se detecta ESC
            	in.read(); // Lee y descarta '['
            	ch= in.read();
                 	switch (ch) {
                    	case 'C' -> {
                        	return RIGHT; // Flecha derecha (Right Arrow)
            	}
                    	case 'D' -> {
                        	return LEFT;
            	}
                    	}
        	}// Flecha izquierda (Left Arrow)
       	return ch;
	}
 
	public static void main(String[] args) throws IOException {
    	int arrow;
    	ConsoleBar con = null;
    	Value value = null;
   	 
    	try {
       	 
        	value = new Value();
        	con = new ConsoleBar(value);
       	 
        	setRaw();
        	value.setMax(20); // Establecer el máximo de columnas, por ejemplo
        	value.addObserver(con);
       	 
        	while ((arrow = readArrow()) != '\r') {
            	if (arrow == RIGHT)
                	value.inc(); // Incrementar el valor si se presiona flecha derecha
            	else if (arrow == LEFT)
                	value.dec(); // Decrementar el valor si se presiona flecha izquierda
        	}
    	} finally {
        	unsetRaw();
        	// Limpiar la consola o hacer limpieza necesaria
    	}
	}
}







import java.util.*;

class ConsoleBar implements Observer {
	static enum Opcode {
    	INC, DEC, BELL
	}

	static class Command {
    	Opcode op;

    	Command(Opcode op) {
        	this.op = op;
    	}
	}

    
	Value model;
	static final char BLOCK = '#'; // Character to represent the filled part of the bar

	ConsoleBar(Value value) {
    	model = value;

    	// get max columns (you can set a default value, e.g., 20)
     	// Or you can use a method to calculate it dynamically
    	display();
	}

	@Override
	public void update(Observable o, Object arg) {
    	Command comm = (Command) arg;
    	switch (comm.op) {
        	case INC:
            	display(); // Display when incremented
            	break;
        	case DEC:
            	display(); // Display when decremented
            	break;
        	case BELL:
            	System.out.print('\007'); // Sound a bell
            	break;
    	}
	}

	// Method to display the current value as a bar
	private void display() {
    	int value = model.get();
    	int filledBlocks = (int) ((double) value); // Calculate filled blocks based on max value

    	// Clear the line
    	System.out.print("\r"); // Carriage return to overwrite the current line
    	System.out.print("[");
    	for (int i = 0; i < filledBlocks; i++) {
        	System.out.print(BLOCK); // Print filled blocks
    	}
    	for (int i = filledBlocks; i < model.max; i++) {
        	System.out.print(' '); // Print empty space
    	}
    	System.out.print("] " + value + "/" + model.max + " "); // Show the value and max
    	System.out.flush(); // Ensure everything is printed
	}

//private void display() { //METODE DISPLAY PER ENSENYAR EL PERCENTATGE
   // int value = model.get();
   // int percentage = (int) ((double) value / model.max * 100); // Calculate percentage of the value relative to max

    // Clear the line
   // System.out.print("\r"); // Carriage return to overwrite the current line
    //System.out.print("[");

    // Display percentage
   // System.out.printf("%3d%%", percentage); // Show the percentage (padded to ensure it aligns properly)
    //System.out.print("] " + value + "/" + model.max+ “ ”); // Show the current value and max value

   // System.out.flush(); // Ensure everything is printed
}


}





